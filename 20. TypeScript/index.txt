TYPESCRIPT 

JS: динамічно - слабо типізована мова програмування.

ПРОБЛЕМИ JS
- складність в підтримки великих проктів (багато данних, немає чіткого опису)
- ускладнюється проблема дебага і тестування коду
- відсутній автокомпліт виправлення коду (де підсвічує який тип)

TS - це той самий JS, тільки покращений. Він вже є статичним.

Статичний це - типи перевіряються на етапі компіляції(під час написання коду), а не під час виконання коду.
Явна або виводима типізація
let variable: number = 5; - це явна типізація
let variable = 5; - тут TS сам виводить number

Структурно-взаїмозаміняюча типізація:

type User = {               type Person = {
  fristname: string;           fristname: string;    
  Lastname: string;            Lastname: string; 
}                           }                 

В двох випадках, якщо ми підставимо, до схожого обєкта один чи інший тип, він буде працювати (таке не підтримується в строго-типізованих мовах).


ТИПИ:
Щоб краще розуміти, потрібно відноситись до типів як до множини, де багато всього. Тобто багато string або number або boolean.

-=-=-=-=-=- 1. Обєднання ( UNION ) -=-=-=-=-=-=-

В даному випадку можна для змінної присвоїти текст або числа.
let data: number | string;
data = 5;
data = 'str'

let color: 'red' | 'green';


В прикладі нижче, на рядку 49 ми обєднуємо 2 типи і можемо створити такий собі тип, що буде брати 3 різні значення.
type MainInfo = {
  firstname: string;
  lastname: string;
}

type AdditionalInfo = {
  age: number;
}

type FullInfo = AdditionalInfo | MainInfo;

const info0: FullInfo = { firstname: '123', lastname: '123', age: 123 };
const info1: FullInfo = { firstname: '123', lastname: '123' };
const info2: FullInfo = { age: 123 };


-=-=-=-=-=- 2. Пересічення ( INTERSECTION ) -=-=-=-=-=-=-

В прикладі нижче, на рядку 68 ми через амперсанд, вказуємо що буде або те, або те. string i number разом не можуть бути.
type MainInfo = {
  firstname: string;
  lastname: string;
}

type AdditionalInfo = {
  age: number;
}

type FullInfo = AdditionalInfo & MainInfo;

const info0: FullInfo = { firstname: '123', lastname: '123', age: 123 };
const info1: FullInfo = { firstname: '123', lastname: '123' };
const info2: FullInfo = { age: 123 };


-=-=-=-=-=- 3. Надтип ( SUPER TYPE ) і Підтип ( SUBTYPE ) -=-=-=-=-=-=-

Підтип включає всі властивості і/або методи надтипа, плюс може добавити свої.

Надтип може включати менше властивостей і/або методів, чим підтип.

Обєкт підтипа може бути призначений змінній надтипа. Зворотнє не завжди можливо без приведення типів.


-=-=-=-=-=- 4. Спеціальні типи -=-=-=-=-=-=-
-=-=-=-=-=- ANY UNKNOWN NEVER VOID -=-=-=-=-=-=-

ANY - просто виключає перевірку TS.

UNKNOWN - я не знаю, що це, але щось є. unknown означає: тип є, але ми не знаємо який. TypeScript каже: "Я не впевнений, що там, тому будь обережний."
Використовуємо unknown, коли отримуємо дані ззовні (наприклад, з API), і треба їх спочатку перевірити.

NEVER - це ніколи не відбувається. never — це тип, який неможливо отримати.
function throwError(message: string): never {
  throw new Error(message); - Функція нічого не повертає і ніколи не дійде до кінця.
}

VOID - нічого не повертає. void зазвичай означає, що функція нічого не повертає (або повертає “нічого важливого”).
let result = sayHello(); // result: void (тобто undefined)


-=-=-=-=-=- 5. ІНТЕРФЕЙСИ І ТИПИ -=-=-=-=-=-=-

Найчастіше використовується в TS. Між ними особливої різниці немає, що той що той, працює одинаково.

Якщо описуємо обєкт або клас - тоді interface.
Якщо описуємо щось складніше, (типи, юніони, функції, джейнеріки) - використовуємо type

? знак питання ставиться, якщо якийсь тип є не обовязковим.

interface Address {
  city?: string;
  street?: string;
  coords: number[];
}

type User = {
  firstname: string;
  age?: number;
  address: Address;
}

type ComponentProps = {
  className: string;
  color: 'red' | 'green';
}

type ApiResponse<T> = {
  status: 'success' | 'error';
  data?: T;
}


-=-=-=-=-=- 6. ЛІТЕРАЛИ -=-=-=-=-=-=-

Це щось схоже, на оператор АБО.
Внизу приклади, де може бути варіант, один з трьох.

type Color = 'red' | 'green' | 'blue'
type Size = 4 | 8 | 16

* as const * каже TypeScript:
“Не міняй ці значення, і не розширюй їх типи — запам’ятай їх такими, як вони є зараз.” 

const colors = ["red", "green", "blue"];
TypeScript подумає:
string[] - Тобто: “масив рядків” — але які саме рядки, він не запам’ятав.

const colors = ["red", "green", "blue"] as const;
Тепер для TS тип виглядає ось так:
readonly ["red", "green", "blue"]

as const — каже TypeScript:
“Трактуй це як константу з фіксованими значеннями, а не як просто змінну типу string чи number.”


-=-=-=-=-=- 7. GENERICS -=-=-=-=-=-=-

GENERICS - це як аргумент у функції, тільки це тип.

<T> це від назви TYPE, там можна вказати будь яку назву.
interface ApiResponse<T> {
  status?: 'error' | 'success';
  meta?: MetaData;
  requestId?: string;
  data: T; - Таким чином, ми вказуємо назву Джейнеріка і потім якщо потрібно, можемо підставити той тип, який нам потрібно, наприклад якщо в DATA у нас приходять різні данні.
}

const responseFromUserApi: ApiResponse<User> = {
  data: {
    username: 'Ivan'
  }
}
const responseFromArticleApi: ApiResponse<Article> = {
  data: {
    title: '123'
  }
}













-=-=-=-=-=- .  -=-=-=-=-=-=-





-=-=-=-=-=- .  -=-=-=-=-=-=-